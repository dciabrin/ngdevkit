#!/usr/bin/env python3
# Copyright (c) 2024 Damien Ciabrini
# This file is part of ngdevkit
#
# ngdevkit is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# ngdevkit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with ngdevkit.  If not, see <http://www.gnu.org/licenses/>.

"""soundtool.py - generate command data for z80 and m68k."""

import argparse
import re
import sys
import yaml
import glob
import os
import wave

VERBOSE = False


def error(s):
    sys.exit("error: " + s)


def dbg(s):
    if VERBOSE:
        print(s, file=sys.stderr)

def mkid(x):
    return re.sub(r"\W|^(?=\d)", "_", x).lower()


def load_sound_desc(descfile):
    descdata = open(descfile,'r').read()
    comments = [l for l in descdata.split('\n') if re.search(r'^#', l)]
    header = "\n".join(comments)
    yamldata = sum(list(yaml.safe_load_all(descdata)), [])
    return header+"\n", yamldata


def generate_sound_desc(entries, header, desc, output):
    def merge_descs(a,b):
        atype = list(a.keys())[0]
        adata = a[atype]
        btype = list(b.keys())[0]
        bdata = b[btype]
        return {atype: {**adata, **bdata}}

    def detect_adpcm_type(f):
        try:
            w = wave.open(f, 'rb')
            assert w.getnchannels() == 1, "Only mono WAV file is supported"
            assert w.getsampwidth() == 2, "Only 16bits per sample is supported"
            assert w.getcomptype() == 'NONE', "Only uncompressed WAV file is supported"
            wavrate = w.getframerate()
            return "adpcm_a" if wavrate == 18500 else "adpcm_b"
        except Exception as e:
            return ""

    existing_data = {}
    for i in desc:
        itemtype = list(i.keys())[0]
        itemdata = i[itemtype]
        existing_data[itemdata['name']] = i

    read_data = []
    for e in entries:
        if os.path.isdir(e):
            e=os.path.join(e,'**')
        for f in glob.iglob(e, recursive=True):
            if not os.path.isfile(f):
                continue
            if os.path.splitext(f)[1] not in ('.fur', '.adpcma', '.adpcmb', '.wav'):
                continue
            if f.endswith('fur'):
                # Furnace module
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                read_data.append([name, {'furnace': {'name': name, 'uri': uri}}])
            else:
                # individual sample
                # TODO improve the logic
                sfxtype=''
                if '.adpcma' in f.lower():
                    sfxtype = 'adpcm_a'
                elif '.adpcmb' in f.lower():
                    sfxtype = 'adpcm_b'
                elif '.wav' in f.lower():
                    sfxtype = detect_adpcm_type(f)
                    if not sfxtype:
                        error("could not autodetect a suitable ADPCM format for '%s'"%f)
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                sfx = {'name': name, 'uri': uri}
                sfxdir=os.path.basename(os.path.dirname(f))
                if re.match(r'^[1-6]$',sfxdir):
                    sfx['channel']=int(sfxdir)
                read_data.append([name, {sfxtype: sfx}])

    result_data = []
    # reconcile existing data and read data
    for n, data in read_data:
        if n in existing_data.keys():
            result_data.append(merge_descs(existing_data[n], data))
        else:
            result_data.append(data)

    # save sound map description
    print(header, end='', file=output)
    print(yaml.dump(result_data), end='', file=output)



def parse_cmd(i):
    k=list(i.keys())[0]
    v=i[k]
    stype='music' if k == 'nss' else k
    return stype, v


def dump_m68k_commands(desc, f):
    print('#ifndef _SND_COMMANDS_', file=f)
    print('#define _SND_COMMANDS_ 1', file=f)
    print('', file=f)
    print("/* macros definitions for music and sfx commands", file=f)
    print(" * generated by soundtool.py (ngdevkit)", file=f)
    print(" */", file=f)
    print('', file=f)

    print('#ifndef _SND_CMD_BASE_GENERATED', file=f)
    print('#define _SND_CMD_BASE_GENERATED 4', file=f)
    print('#endif', file=f)
    print('', file=f)
    nb_music=sum([1 if 'furnace' in x else 0 for x in desc])
    print('#define SND_NB_MUSIC (%d)'%nb_music, file=f)
    nb_fx=len(desc)-nb_music
    print('#define SND_NB_FX (%d)'%nb_fx, file=f)
    print('#define SND_LAST (_SND_CMD_BASE_GENERATED + %d - 1)'%len(desc), file=f)
    print('', file=f)
    for n, i in enumerate(desc):
        stype, data = parse_cmd(i)
        if stype == 'furnace':
            stype = 'music'
        else:
            stype = 'sfx'
        name='SND_%s_%s'%(stype.upper(),data['name'].upper())
        print('#define %s (_SND_CMD_BASE_GENERATED + %d)'%(name,n), file=f)
    print('', file=f)
    print('#endif /* _SND_COMMANDS_ */', file=f)


def dump_z80_commands(desc, f):
    def print_jp_cmd(stype, data):
        stype='sfx' if 'adpcm' in stype else 'music'
        name=data['name']
        print('        jp      %s_%s'%(stype,name), file=f)

    def print_music_cmd(data):
        name=data['name']
        print('music_%s::'%name, file=f)
        print('        ld      bc, #instruments_%s'%name, file=f)
        print('        ld      de, #nss_%s'%name, file=f)
        print('        call    snd_stream_play', file=f)
        print('        ret', file=f)
        print('', file=f)

    def print_sfx_cmd(stype, data):
        name=data['name']
        channel=data.get('channel', 6)-1
        ucname=name.upper()
        print('sfx_%s::'%name, file=f)
        print('        ld      ix, #sfx_%s_data'%name, file=f)
        print('        call    snd_%s_play'%stype, file=f)
        print('        ret', file=f)
        print('sfx_%s_data:'%name, file=f)
        print('        .db     %s_START_LSB, %s_START_MSB ; start>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     %s_STOP_LSB, %s_STOP_MSB   ; stop>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     0x%02x ; channel'%channel, file=f)
        print('        .db     0xda ; l/r output + volume', file=f)
        print('        .db     0x%02x ; channel (bit)'%(1<<channel), file=f)
        print('', file=f)

    print(";;; macros definitions for music and sfx commands", file=f)
    print(";;; generated by soundtool.py (ngdevkit)", file=f)
    print('', file=f)

    print('        .macro generated_commands_jmptable_entries', file=f)
    for i in desc:
        stype, data = parse_cmd(i)
        print_jp_cmd(stype, data)
    print('        .endm', file=f)

    print('', file=f)

    print('        .macro generated_commands_implementation', file=f)
    for i in desc:
        stype, data = parse_cmd(i)
        if stype == 'furnace':
            print_music_cmd(data)
        if 'adpcm' in stype:
            print_sfx_cmd(stype, data)
    print('        .endm', file=f)


def main():
    global VERBOSE
    parser = argparse.ArgumentParser(
        description="Manage ADPCM sample offsets in VROMs")

    paction = parser.add_argument_group("action")
    pmode = paction.add_mutually_exclusive_group(required=True)
    pmode.add_argument("-c", "--c-header", action="store_const",
                       const="c-header", dest="action",
                       help="output m68k C header for sound commands")
    pmode.add_argument("-z", "--z80", action="store_const",
                       const="z80", dest="action",
                       help="output z80 action table and commands implementation")
    pmode.add_argument("-g", "--generate", action="store_const",
                       const="generate", dest="action",
                       help="generate a template sound map to be customized by user")

    parser.add_argument("FILE", nargs="*",
                        help="Input sound assets directories for the --generate action")
    parser.add_argument("-s", "--soundmap", nargs="+",
                        help="Input soundmap to be used by action")

    parser.add_argument("-o", "--output",
                        help="Output file path, contents depends on the action")

    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                        default=False, help="print details of processing")

    arguments = parser.parse_args()
    VERBOSE = arguments.verbose

    if arguments.action in ['c-header', 'z80']:
        if not arguments.soundmap:
            error('option --soundmap is required for action --%s'%arguments.action)

    header = """# sound assets map
# generated by soundtool.py (ngdevkit)
# you can add your customization below
# ---
"""
    desc = []

    if arguments.output:
        # When the generate option is used and the output already exists on disk,
        # soundtool performs an update action:
        #   . it only keeps data for sound files passed in input arguments.FILE
        #   . it keeps any customization found in the existing desc for those sound files
        if arguments.action == 'generate' and os.path.isfile(arguments.output):
            header, desc = load_sound_desc(arguments.output)
        output = open(arguments.output, 'w')
    else:
        output = sys.__stdout__

    # Generate sound map from files on disk
    if arguments.action == 'generate':
        generate_sound_desc(arguments.FILE, header, desc, output)
        sys.exit(0)

    # Otherwise load a sound map from the input yaml file
    for smap in arguments.soundmap:
        with open(smap, 'r') as f:
            desc.extend(yaml.safe_load(f.read()))

    # generate z80 macros
    if arguments.action == 'z80':
        dump_z80_commands(desc, output)

    # generate m68k header
    if arguments.action == 'c-header':
        dump_m68k_commands(desc, output)


if __name__ == "__main__":
    main()
