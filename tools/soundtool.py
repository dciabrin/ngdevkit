#!/usr/bin/env python3
# Copyright (c) 2024 Damien Ciabrini
# This file is part of ngdevkit
#
# ngdevkit is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# ngdevkit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with ngdevkit.  If not, see <http://www.gnu.org/licenses/>.

"""soundtool.py - generate command data for z80 and m68k."""

import argparse
import re
import sys
import yaml
import glob
import os
import wave

VERBOSE = False


def error(s):
    sys.exit("error: " + s)


def dbg(s):
    if VERBOSE:
        print(s, file=sys.stderr)

def mkid(x):
    return re.sub(r"\W|^(?=\d)", "_", x).lower()


def load_sound_desc(descfile):
    descdata = open(descfile,'r').read()
    comments = [l for l in descdata.split('\n') if re.search(r'^#', l)]
    header = "\n".join(comments)
    yamldata = sum(list(yaml.safe_load_all(descdata)), [])
    return header+"\n", yamldata


def generate_sound_desc(entries, header, desc, output):
    def merge_descs(a,b):
        atype = list(a.keys())[0]
        adata = a[atype]
        btype = list(b.keys())[0]
        bdata = b[btype]
        return {atype: {**adata, **bdata}}

    def detect_adpcm_type(f):
        try:
            w = wave.open(f, 'rb')
            assert w.getnchannels() == 1, "Only mono WAV file is supported"
            assert w.getsampwidth() == 2, "Only 16bits per sample is supported"
            assert w.getcomptype() == 'NONE', "Only uncompressed WAV file is supported"
            wavrate = w.getframerate()
            return "adpcm_a" if wavrate == 18500 else "adpcm_b"
        except Exception as e:
            return ""

    existing_data = {}
    for i in desc:
        itemtype = list(i.keys())[0]
        itemdata = i[itemtype]
        existing_data[itemdata['name']] = i

    read_data = []
    for e in entries:
        if os.path.isdir(e):
            e=os.path.join(e,'**')
        for f in glob.iglob(e, recursive=True):
            if not os.path.isfile(f):
                continue
            if os.path.splitext(f)[1] not in ('.fur', '.adpcma', '.adpcmb', '.wav'):
                continue
            if f.endswith('fur'):
                # Furnace module
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                read_data.append([name, {'furnace': {'name': name, 'uri': uri}}])
            else:
                # individual sample
                # TODO improve the logic
                sfxtype=''
                if '.adpcma' in f.lower():
                    sfxtype = 'adpcm_a'
                elif '.adpcmb' in f.lower():
                    sfxtype = 'adpcm_b'
                elif '.wav' in f.lower():
                    sfxtype = detect_adpcm_type(f)
                    if not sfxtype:
                        error("could not autodetect a suitable ADPCM format for '%s'"%f)
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                sfx = {'name': name, 'uri': uri}
                sfxdir=os.path.basename(os.path.dirname(f))
                if re.match(r'^[1-6]$',sfxdir):
                    sfx['channel']=int(sfxdir)
                read_data.append([name, {sfxtype: sfx}])

    result_data = []
    # reconcile existing data and read data
    for n, data in read_data:
        if n in existing_data.keys():
            result_data.append(merge_descs(existing_data[n], data))
        else:
            result_data.append(data)

    # save sound map description
    print(header, end='', file=output)
    print(yaml.dump(result_data), end='', file=output)



def parse_cmd(i):
    k=list(i.keys())[0]
    v=i[k]
    stype='music' if k == 'nss' else k
    return stype, v


def group_assets(desc):
    # sort sound assets by ROM target (fixed or banked)
    grouped_musics = {}
    grouped_sfxs = {}
    for d in desc:
        dtype = next(iter(d))
        dmap = grouped_musics if dtype == 'furnace' else grouped_sfxs
        dloc = d[dtype].get('bank', -1)
        data = dmap.get(dloc, [])
        data.append(d)
        dmap[dloc] = data
    return grouped_musics, grouped_sfxs


def dump_m68k_commands(desc, f):
    print('#ifndef _SND_COMMANDS_', file=f)
    print('#define _SND_COMMANDS_ 1', file=f)
    print('', file=f)
    print("/* macros definitions for music and sfx commands", file=f)
    print(" * generated by soundtool.py (ngdevkit)", file=f)
    print(" */", file=f)
    print('', file=f)

    print('#ifndef _SND_CMD_BASE_GENERATED', file=f)
    print('#define _SND_CMD_BASE_GENERATED 4', file=f)
    print('#endif', file=f)
    print('', file=f)
    nb_music=sum([1 if 'furnace' in x else 0 for x in desc])
    print('#define SND_NB_MUSIC (%d)'%nb_music, file=f)
    nb_fx=len(desc)-nb_music
    print('#define SND_NB_FX (%d)'%nb_fx, file=f)
    print('#define SND_LAST (_SND_CMD_BASE_GENERATED + %d - 1)'%len(desc), file=f)
    print('', file=f)
    for n, i in enumerate(desc):
        stype, data = parse_cmd(i)
        if stype == 'furnace':
            stype = 'music'
        else:
            stype = 'sfx'
        name='SND_%s_%s'%(stype.upper(),data['name'].upper())
        print('#define %s (_SND_CMD_BASE_GENERATED + %d)'%(name,n), file=f)
    print('', file=f)
    print('#endif /* _SND_COMMANDS_ */', file=f)


def dump_z80_commands(desc, f):
    def print_jp_cmd(stype, data, bank):
        stype='sfx' if 'adpcm' in stype else 'music'
        name=data['name']
        print('        jp      %s_%s'%(stype,name), file=f)

    def print_music_cmd(stype, data, bank):
        name=data['name']
        print('music_%s::'%name, file=f)
        if bank >= 0:
            print('        call    snd_stream_stop', file=f)
            print('        ld      bc, #bank_table+%d*4'%bank, file=f)
            print('        call    bank_switch', file=f)
        print('        ld      bc, #instruments_%s'%name, file=f)
        print('        ld      de, #nss_%s'%name, file=f)
        print('        call    snd_stream_play', file=f)
        print('        ret', file=f)
        print('', file=f)

    def print_sfx_cmd(stype, data, bank):
        name=data['name']
        channel=data.get('channel', 6)-1
        ucname=name.upper()
        print('sfx_%s::'%name, file=f)
        print('        ld      ix, #sfx_%s_data'%name, file=f)
        print('        call    snd_%s_play'%stype, file=f)
        print('        ret', file=f)
        print('sfx_%s_data:'%name, file=f)
        print('        .db     %s_START_LSB, %s_START_MSB ; start>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     %s_STOP_LSB, %s_STOP_MSB   ; stop>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     0x%02x ; channel'%channel, file=f)
        print('        .db     0xda ; l/r output + volume', file=f)
        print('        .db     0x%02x ; channel (bit)'%(1<<channel), file=f)
        print('', file=f)

    def print_banks(banks):
        def bank_windows(bank):
            windows = []
            offset = 0x8000 + (0x8000 * bank)
            for w in (0x4000, 0x2000, 0x1000, 0x0800):
                windows.insert(0, offset // w)
                offset = offset + w
            return windows

        print('        .macro bank_table', file=f)
        print('bank_table::', file=f)
        for b in banks:
            w = bank_windows(b)
            data = ", ".join(["0x%02x"%w for w in bank_windows(b)])
            start = 0x8000 * b
            stop = start + 0x7fff
            print('        .db     %s ; bank %d: [0x%05x..0x%05x]'%(data, b, start, stop), file=f)
        print('        .endm', file=f)
        print('', file=f)

    def print_asset(name, func, desc, bank):
        print('        .macro %s'%name, file=f)
        for d in desc:
            stype, data = parse_cmd(d)
            func(stype, data, bank)
        print('        .endm', file=f)
        print('', file=f)

    print(";;; macros definitions for music and sfx commands", file=f)
    print(";;; generated by soundtool.py (ngdevkit)", file=f)
    print('', file=f)

    grouped_musics, grouped_sfxs = group_assets(desc)

    # Jump table macros
    for group in sorted(iter(grouped_musics)):
        suffix = "" if group == -1 else "_bank%d"%group
        print_asset("jmptable_music"+suffix, print_jp_cmd, grouped_musics[group], group)

    for group in sorted(iter(grouped_sfxs)):
        suffix = "" if group == -1 else "_bank%d"%group
        print_asset("jmptable_sfx"+suffix, print_jp_cmd, grouped_sfxs[group], group)

    if (grouped_musics or grouped_sfxs):
        print('        .macro generated_commands_jmptable_entries', file=f)
        for group in sorted(iter(grouped_musics)):
            suffix = "" if group == -1 else "_bank%d"%group
            print('        %s'%("jmptable_music"+suffix,), file=f)
        for group in sorted(iter(grouped_sfxs)):
            suffix = "" if group == -1 else "_bank%d"%group
            print('        %s'%("jmptable_sfx"+suffix,), file=f)
        print('        .endm', file=f)
        print('', file=f)

    banks = list(set([x[next(iter(x))]['bank'] for x in desc if 'bank' in x[next(iter(x))]]))

    if banks:
        print_banks(banks)

    # command macros
    for group in sorted(iter(grouped_musics)):
        suffix = "" if group == -1 else "_bank%d"%group
        print_asset("commands_music"+suffix, print_music_cmd, grouped_musics[group], group)

    for group in sorted(iter(grouped_sfxs)):
        suffix = "" if group == -1 else "_bank%d"%group
        print_asset("commands_sfx"+suffix, print_sfx_cmd, grouped_sfxs[group], group)

    if (grouped_musics or grouped_sfxs):
        print('        .macro generated_commands_implementation', file=f)
        if banks:
            print('        bank_table', file=f)
        for group in sorted(iter(grouped_musics)):
            suffix = "" if group == -1 else "_bank%d"%group
            print('        %s'%("commands_music"+suffix,), file=f)
        for group in sorted(iter(grouped_sfxs)):
            suffix = "" if group == -1 else "_bank%d"%group
            print('        %s'%("commands_sfx"+suffix,), file=f)
        print('        .endm', file=f)
        print('', file=f)


def dump_makefile(desc, f):
    def print_asset(name, module, bank):
        print('        .macro %s'%name, file=f)
        for d in desc:
            stype, data = parse_cmd(d)
            func(stype, data, bank)
        print('        .endm', file=f)
        print('', file=f)

    print("# dependencies for generated sound assets", file=f)
    print("# generated by soundtool.py (ngdevkit)", file=f)
    print('', file=f)

    print('GENERATED_MUSIC?=.', file=f)
    print('', file=f)

    grouped_musics, _ = group_assets(desc)

    # Jump table macros
    for group in sorted(iter(grouped_musics)):
        atype="Z80 bank %d"%group if group >= 0 else "fixed Z80 ROM"
        print("#\n# assets for %s\n#\n"%atype, file=f)
        for mod in grouped_musics[group]:
            mtype="BANK%d"%group if group >= 0 else "FIXED"
            gtype="BANK%d_MUSIC"%group if group >= 0 else "MUSIC"
            uri=mod['furnace']['uri']
            path=uri.split("://")[1]
            filename=os.path.splitext(os.path.basename(path))[0]
            print("$(GENERATED_MUSIC)/instruments-%s.s: %s"%(filename, path), file=f)
            print("$(GENERATED_MUSIC)/nss-%s.s: %s"%(filename, path), file=f)
            print("Z80_%s_MUSIC+=$(GENERATED_MUSIC)/instruments-%s.s"%(mtype, filename), file=f)
            print("Z80_%s_MUSIC+=$(GENERATED_MUSIC)/nss-%s.s"%(mtype, filename), file=f)
            print("Z80_%s_OBJS=$(Z80_%s_MUSIC:%%.s=%%.rel)"%(gtype, mtype), file=f)
            print("Z80_SOUND_SRCS+=$(Z80_%s_MUSIC)"%mtype, file=f)
            if group >= 0:
                print("Z80_MUSIC_OBJS+=$(Z80_BANK_PREFIX)%d.lib"%group, file=f)
                print("Z80_LDFLAGS+=-b BANK%d=0x8000"%group, file=f)
                print("$(Z80_BANK%d_MUSIC): Z80_FLAGS=-b %d"%(group, group), file=f)
                print("$(Z80_BANK%d_MUSIC_OBJS): $(SAMPLES_INC)"%group, file=f)
                print("$(Z80_BANK_PREFIX)%d.lib: $(Z80_BANK%d_MUSIC_OBJS)"%(group, group), file=f)
                print("Z80_MUSIC_BANKS+=$(Z80_BANK_PREFIX)%d.bin"%group, file=f)

            print('', file=f)



def main():
    global VERBOSE
    parser = argparse.ArgumentParser(
        description="Manage ADPCM sample offsets in VROMs")

    paction = parser.add_argument_group("action")
    pmode = paction.add_mutually_exclusive_group(required=True)
    pmode.add_argument("-c", "--c-header", action="store_const",
                       const="c-header", dest="action",
                       help="output m68k C header for sound commands")
    pmode.add_argument("-z", "--z80", action="store_const",
                       const="z80", dest="action",
                       help="output z80 action table and commands implementation")
    pmode.add_argument("-m", "--makefile", action="store_const",
                       const="makefile", dest="action",
                       help="output makefile dependencies for music assets")
    pmode.add_argument("-g", "--generate", action="store_const",
                       const="generate", dest="action",
                       help="generate a template sound map to be customized by user")

    parser.add_argument("FILE", nargs="*",
                        help="Input sound assets directories for the --generate action")
    parser.add_argument("-s", "--soundmap", nargs="+",
                        help="Input soundmap to be used by action")

    parser.add_argument("-o", "--output",
                        help="Output file path, contents depends on the action")

    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                        default=False, help="print details of processing")

    arguments = parser.parse_args()
    VERBOSE = arguments.verbose

    if arguments.action in ['c-header', 'z80']:
        if not arguments.soundmap:
            error('option --soundmap is required for action --%s'%arguments.action)

    header = """# sound assets map
# generated by soundtool.py (ngdevkit)
# you can add your customization below
# ---
"""
    desc = []

    if arguments.output:
        # When the generate option is used and the output already exists on disk,
        # soundtool performs an update action:
        #   . it only keeps data for sound files passed in input arguments.FILE
        #   . it keeps any customization found in the existing desc for those sound files
        if arguments.action == 'generate' and os.path.isfile(arguments.output):
            header, desc = load_sound_desc(arguments.output)
        output = open(arguments.output, 'w')
    else:
        output = sys.__stdout__

    # Generate sound map from files on disk
    if arguments.action == 'generate':
        generate_sound_desc(arguments.FILE, header, desc, output)
        sys.exit(0)

    # Otherwise load a sound map from the input yaml file
    for smap in arguments.soundmap:
        with open(smap, 'r') as f:
            desc.extend(yaml.safe_load(f.read()))

    # generate z80 macros
    if arguments.action == 'z80':
        dump_z80_commands(desc, output)

    # generate m68k header
    if arguments.action == 'c-header':
        dump_m68k_commands(desc, output)

    # generate m68k header
    if arguments.action == 'makefile':
        dump_makefile(desc, output)


if __name__ == "__main__":
    main()
