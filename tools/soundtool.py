#!/usr/bin/env python3
# Copyright (c) 2024 Damien Ciabrini
# This file is part of ngdevkit
#
# ngdevkit is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# ngdevkit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with ngdevkit.  If not, see <http://www.gnu.org/licenses/>.

"""soundtool.py - generate command data for z80 and m68k."""

import argparse
import re
import sys
import yaml
import glob
import os

VERBOSE = False


def error(s):
    sys.exit("error: " + s)


def dbg(s):
    if VERBOSE:
        print(s, file=sys.stderr)

def mkid(x):
    return re.sub(r"\W|^(?=\d)", "_", x).lower()

def generate_sound_desc(entries):
    desc=[]

    for e in entries:
        if os.path.isdir(e):
            e=os.path.join(e,'**')
        for f in glob.iglob(e, recursive=True):
            if not os.path.isfile(f):
                continue
            if os.path.splitext(f)[1] not in ('.fur', '.adpcma', '.adpcmb'):
                continue
            if f.endswith('fur'):
                # Furnace module
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                desc.append({'furnace': {'name': name, 'uri': uri}})
            else:
                # individual sample
                # TODO improve the logic
                sfxtype=''
                if '.adpcma' in f.lower():
                    sfxtype = 'adpcm_a'
                elif '.adpcmb' in f.lower():
                    sfxtype = 'adpcm_b'
                uri='file://'+f
                name=mkid(os.path.splitext(os.path.basename(f))[0])
                sfx = {'name': name, 'uri': uri}
                sfxdir=os.path.basename(os.path.dirname(f))
                if re.match(r'^[1-6]$',sfxdir):
                    sfx['channel']=int(sfxdir)
                desc.append({sfxtype: sfx})

    return desc



def parse_cmd(i):
    k=list(i.keys())[0]
    v=i[k]
    stype='music' if k == 'nss' else k
    return stype, v


def dump_m68k_commands(desc, f):
    print('#ifndef _SND_COMMANDS_', file=f)
    print('#define _SND_COMMANDS_ 1', file=f)
    print('', file=f)
    print("/* macros definitions for music and sfx commands", file=f)
    print(" * generated by soundtool.py (ngdevkit)", file=f)
    print(" */", file=f)
    print('', file=f)

    print('#ifndef _SND_CMD_BASE_GENERATED', file=f)
    print('#define _SND_CMD_BASE_GENERATED 4', file=f)
    print('#endif', file=f)
    print('', file=f)
    nb_music=sum([1 if 'furnace' in x else 0 for x in desc])
    print('#define SND_NB_MUSIC (%d)'%nb_music, file=f)
    nb_fx=len(desc)-nb_music
    print('#define SND_NB_FX (%d)'%nb_fx, file=f)
    print('#define SND_LAST (_SND_CMD_BASE_GENERATED + %d - 1)'%len(desc), file=f)
    print('', file=f)
    for n, i in enumerate(desc):
        stype, data = parse_cmd(i)
        if stype == 'furnace':
            stype = 'music'
        else:
            stype = 'sfx'
        name='SND_%s_%s'%(stype.upper(),data['name'].upper())
        print('#define %s (_SND_CMD_BASE_GENERATED + %d)'%(name,n), file=f)
    print('', file=f)
    print('#endif /* _SND_COMMANDS_ */', file=f)


def dump_z80_commands(desc, f):
    def print_jp_cmd(stype, data):
        stype='sfx' if 'adpcm' in stype else 'music'
        name=data['name']
        print('        jp      %s_%s'%(stype,name), file=f)

    def print_music_cmd(data):
        name=data['name']
        print('music_%s::'%name, file=f)
        print('        ld      bc, #instruments_%s'%name, file=f)
        print('        ld      de, #nss_%s'%name, file=f)
        print('        call    snd_stream_play', file=f)
        print('        ret', file=f)
        print('', file=f)

    def print_sfx_cmd(stype, data):
        name=data['name']
        channel=data.get('channel', 6)-1
        ucname=name.upper()
        print('sfx_%s::'%name, file=f)
        print('        ld      ix, #sfx_%s_data'%name, file=f)
        print('        call    snd_%s_play'%stype, file=f)
        print('        ret', file=f)
        print('sfx_%s_data:'%name, file=f)
        print('        .db     %s_START_LSB, %s_START_MSB ; start>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     %s_STOP_LSB, %s_STOP_MSB   ; stop>>8 in VROM'%(ucname,ucname), file=f)
        print('        .db     0x%02x ; channel'%channel, file=f)
        print('        .db     0xda ; l/r output + volume', file=f)
        print('        .db     0x%02x ; channel (bit)'%(1<<channel), file=f)
        print('', file=f)

    print(";;; macros definitions for music and sfx commands", file=f)
    print(";;; generated by soundtool.py (ngdevkit)", file=f)
    print('', file=f)

    print('        .macro generated_commands_jmptable_entries', file=f)
    for i in desc:
        stype, data = parse_cmd(i)
        print_jp_cmd(stype, data)
    print('        .endm', file=f)

    print('', file=f)

    print('        .macro generated_commands_implementation', file=f)
    for i in desc:
        stype, data = parse_cmd(i)
        if stype == 'furnace':
            print_music_cmd(data)
        if 'adpcm' in stype:
            print_sfx_cmd(stype, data)
    print('        .endm', file=f)


def main():
    global VERBOSE
    parser = argparse.ArgumentParser(
        description="Manage ADPCM sample offsets in VROMs")

    paction = parser.add_argument_group("action")
    pmode = paction.add_mutually_exclusive_group(required=True)
    pmode.add_argument("-c", "--c-header", action="store_const",
                       const="c-header", dest="action",
                       help="output m68k C header for sound commands")
    pmode.add_argument("-z", "--z80", action="store_const",
                       const="z80", dest="action",
                       help="output z80 action table and commands implementation")
    pmode.add_argument("-g", "--generate", action="store_const",
                       const="generate", dest="action",
                       help="generate a template sound map to be customized by user")

    parser.add_argument("FILE", nargs="*",
                        help="Input sound assets directories for the --generate action")
    parser.add_argument("-s", "--soundmap", nargs="+",
                        help="Input soundmap to be used by action")

    parser.add_argument("-o", "--output",
                        help="Output file path, contents depends on the action")

    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                        default=False, help="print details of processing")

    arguments = parser.parse_args()
    VERBOSE = arguments.verbose

    if arguments.action in ['c-header', 'z80']:
        if not arguments.soundmap:
            error('option --soundmap is required for action --%s'%arguments.action)

    if arguments.output:
        output = open(arguments.output, 'w')
    else:
        output = sys.__stdout__

    desc = []

    # Generate sound map from files on disk
    if arguments.action == 'generate':
        desc = generate_sound_desc(arguments.FILE)
        # save sound map description
        print(yaml.dump(desc), end='', file=output)
        sys.exit(0)

    # Otherwise load a sound map from the input yaml file
    for smap in arguments.soundmap:
        with open(smap, 'r') as f:
            desc.extend(yaml.safe_load(f.read()))

    # generate z80 macros
    if arguments.action == 'z80':
        dump_z80_commands(desc, output)

    # generate m68k header
    if arguments.action == 'c-header':
        dump_m68k_commands(desc, output)


if __name__ == "__main__":
    main()
